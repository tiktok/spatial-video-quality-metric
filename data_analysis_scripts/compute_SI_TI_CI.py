import osimport numpy as npimport cv2import multiprocessing as mpimport tqdmimport pandas as pdimport avfrom scipy import ndimageimport imageioimport numpy as npdef videoset_iterator(data_dir):    for entry in os.scandir(data_dir):        if entry.is_dir(follow_symlinks=False):            yield from videoset_iterator(entry.path)        else:            if '.mov' in entry.name:                yield (entry.name, entry.path)def video_iterator(input_file):    container = av.open(input_file)    for frame_number, frame in enumerate(container.decode(video=0)):        if frame_number % 30 == 0:            yield frame.to_ndarray(format="gray").astype("int")# def video_iterator(video):#     total_frames = int(video.get(cv2.CAP_PROP_FRAME_COUNT))#     for i in range(0, total_frames, 10):  # Jump to every 10th frame#         video.set(cv2.CAP_PROP_POS_FRAMES, i)#         ret, frame = video.read()#         if not ret:#             break#         yield framedef calculate_features(input_file):  # renamed video to input_file to reflect that it's a file path    spatial_infos = []    temporal_infos = []    color_infos = []    prev_frame = None    for frame in video_iterator(input_file):  # directly use the file path here        frame_grey = frame                # Spatial info        sobelx = ndimage.sobel(frame_grey, axis=0)        sobely = ndimage.sobel(frame_grey, axis=1)        magnitude = np.sqrt(sobelx**2.0 + sobely**2.0)        magnitude = magnitude[1:-1, 1:-1]        spatial_info = np.std(magnitude)        spatial_infos.append(spatial_info)                # Temporal info        if prev_frame is not None:            diff = frame_grey - prev_frame            temporal_info = np.std(diff)            temporal_infos.append(temporal_info)        prev_frame = frame_grey                # Color info        rg = frame[..., 2] - frame[..., 1]        yb = 0.5 * (frame[..., 2] + frame[..., 1]) - frame[..., 0]#        import pdb;pdb.set_trace()        color_infos.append(np.sqrt(np.var(rg) + np.var(yb)) + 0.3 * np.sqrt(np.mean(rg) ** 2 + np.mean(yb) ** 2))        spatial_info_ret = np.mean(spatial_infos)    temporal_info_ret = np.mean(temporal_infos)    color_info_ret = np.mean(color_infos)    return (spatial_info_ret, temporal_info_ret, color_info_ret)# def get_video_infos(video_metadata):#     name, path = video_metadata#     video = cv2.VideoCapture(path)#     return (name, calculate_features(video))def get_video_infos(video_metadata):    name, path = video_metadata    return (name, calculate_features(path))  # pass the file path instead of the video objectdef get_video_stats(data_dir):    stats = {}    with mp.Pool() as p:        with tqdm.tqdm(total=224) as progress_bar:            for name, infos in p.imap(get_video_infos, videoset_iterator(data_dir)):                stats[name] = infos                progress_bar.update(1)    return statsdef main():    dataset = './videos'    data_dir = dataset    out_path = './SI_TI_CI/' + dataset +'_SI_TI_CI.csv'    video_stats = get_video_stats(data_dir)    # print(video_stats)    df = pd.DataFrame.from_dict(video_stats, orient='index', columns=['SI', 'TI', 'CI'])    df.to_csv(out_path)    print("Feature Extraction Complete!!")if __name__ == "__main__":    main()